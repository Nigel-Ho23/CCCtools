---
title: "Finding Consensus with CellPhoneDBv5"
author: "Adaikalavan Ramasamy, Gokce Oguz, Ho Jin Ker Nigel"
date: 07/18/2025
format: 
  html:
    toc: true
    toc-location: left
editor: visual
editor_options: 
  chunk_output_type: console
execute:
  message: false
  warning: false
---

This document is for outlining the mapping process of interactions generated from cell-cell communication (CCC) analysis - using both CellPhoneDBv5 and CellChatv2.

CellChat is used as the reference CCC tool, and we want to find out which interactions in CellChat are supported by CellPhoneDB. To ensure high confidence and unbiased mapping, we convert all gene symbols to their respective Uniprot IDs in both CCC tools, and do the same for the subunits of complexes.

# 1. Setup

## 1.1. R setup

```{r}
pacman::p_load(tidyverse, readxl, writexl, janitor, CellChat, ggvenn, biomaRt, 
               conflicted, tidytext, DT, kableExtra)
setwd(this.path::here())
rm(list = ls())

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("setdiff", "base")

# removes NA from all kable
options(knitr.kable.NA = "") 
```

## 1.2. Folder setup

```{r}
#| eval: false
sapply( c("data", "results"), dir.create, recursive = TRUE )
```

## 1.3. Download CellPhoneDB data files

These files were downloaded on 11th July 2025.

```{r}
#| eval: false
basepath <- "https://raw.github.com/ventolab/cellphonedb-data/refs/heads/master"

# Main database containing the interaction
download.file( file.path(basepath, "cellphonedb.zip"), "data/cellphonedb.zip" )
unzip("data/cellphonedb.zip", exdir = "data", junkpaths = TRUE)

# Additional files for mapping
download.file( file.path(basepath, "data/complex_input.csv"), "data/complex_input.csv" )
download.file( file.path(basepath, "data/protein_input.csv"), "data/protein_input.csv" )
download.file( file.path(basepath, "data/sources/uniprot_synonyms.tsv"), "data/uniprot_synonyms.tsv" )
```

# 2. Complex Mapping

## 2.1. Mapping CellPhoneDB complexes to Uniprot IDs

```{r}
CPDB.complex2protein <- read_csv("data/complex_input.csv") %>% 
  select(complex_name, starts_with("uniprot"))

example <- c("12oxoLeukotrieneB4_byPTGR1", "TREM2_receptor", "RAreceptor_RARA_RXRA",
             "Pregnenolone_byCYP11A1", "5HTR3_complex")
```

```{r}
CPDB.complex2protein %>% 
  filter(complex_name %in% example) %>% 
  mutate(complex_name = factor(complex_name, levels = example)) %>% 
  arrange(complex_name) %>% 
  knitr::kable()
```

```{r}
CPDB.complex2protein %>% 
  mutate(nproteins_per_complex = rowSums(!is.na(across(starts_with("uniprot"))))) %>% 
  tabyl(nproteins_per_complex) %>% 
  knitr::kable(align = rep("l", nrow(.)))
```

<br> There are `r nrow(CPDB.complex2protein)` complexes and each complex can include up to 5 proteins (but typically 2).

## 2.2. Add a unique key for matching

To create the complex key, we concatenated the subunits of heteromeric complexes into a vector, removed NAs within, and sorted the subunits before collapsing them into a single character value. We found that sorting eases the mapping process computationally between CellPhoneDB and CellChat (Before sort: \< 250 mapped; After sort: \> 290 mapped).

```{r}
CPDB.complex2protein <- CPDB.complex2protein %>% 
  rowwise() %>% 
  mutate(complex_key = paste(
    sort(na.omit(c(uniprot_1, uniprot_2, uniprot_3, uniprot_4, uniprot_5))), 
    collapse = "_")) %>% 
  ungroup()
```

```{r}
CPDB.complex2protein %>% 
  filter(complex_name %in% example) %>% 
  mutate(complex_name = factor(complex_name, levels = example)) %>% 
  arrange(complex_name) %>% 
  knitr::kable()
```

## 2.3. Mapping CellChatDB complexes to Uniprot IDs

CellChat version 2.2.0 stores the database within R under `CellChatDB.human`.

```{r}
pacman::p_version("CellChat")

CCDB.complex2gene <- CellChatDB.human$complex %>% 
  mutate(complex_name = rownames(.)) %>% 
  rename_with( ~ gsub("subunit", "symbol", .)) %>% 
  relocate(complex_name) %>% 
  remove_rownames()

example <- c("12oxoLTB4-PTGR1", "TREM2_TYROBP", "RARA_RXRA_CRABP2", 
             "Pregnenolone-CYP11A1", "HTR3_complex")

CCDB.complex2gene %>% dim()

CCDB.complex2gene %>% 
  filter(complex_name %in% example) %>% 
  knitr::kable()
```

<br> We need to map the gene symbols to uniprot IDs to make this database compatible with CellPhoneDB.

```{r}
CCDB.protein2gene <- CellChatDB.human$geneInfo %>% 
  select(EntryID.uniprot, Symbol)

CCDB.protein2gene %>% dim()

CCDB.protein2gene %>% head()

## Map gene symbol to uniprot
CCDB.complex2protein <- CCDB.complex2gene %>% 
  pivot_longer(cols = !complex_name) %>% 
  left_join(CCDB.protein2gene, by = c("value" = "Symbol")) %>% 
  select(complex_name, name, EntryID.uniprot) %>% 
  pivot_wider(id_cols = complex_name, names_from = "name", values_from = "EntryID.uniprot") %>% 
  rename_with( ~ gsub("symbol", "uniprot", .))

CCDB.complex2protein %>% 
  filter(complex_name %in% example) %>% 
  knitr::kable()
```

<br> Again, we can count the number of proteins per complex:

```{r}
CCDB.complex2protein %>% 
  mutate(nproteins_per_complex = rowSums(!is.na(across(starts_with("uniprot"))))) %>% 
  tabyl(nproteins_per_complex) %>% 
  knitr::kable(align = rep("l", nrow(.)))
```

<br> Now, let's add a key to help with the comparison, using the same logic from CellPhoneDB.

```{r}
CCDB.complex2protein <- CCDB.complex2protein %>% 
  rowwise() %>% 
  mutate(complex_key = paste(
    sort(na.omit(c(uniprot_1, uniprot_2, uniprot_3, uniprot_4, uniprot_5))), 
    collapse = "_")) %>% 
  ungroup()
```

```{r}
CCDB.complex2protein %>% 
  filter(complex_name %in% example) %>%
  knitr::kable()
```

## 2.4. Duplicate keys

Before we merge, let us pull out the duplicate keys within each database for **manual curation**.

```{r}
CPDB.complex2protein.uniq <- CPDB.complex2protein %>% 
  add_count(complex_key) %>% 
  filter(n == 1) %>% 
  select(-n) 

CPDB.complex2protein.dup <- CPDB.complex2protein %>% 
  add_count(complex_key) %>% 
  filter(n > 1) %>% 
  select(-n) %>% 
  arrange(complex_key)
```

### Duplicate complex keys in CellPhoneDB

```{r}
CPDB.complex2protein.dup %>% 
  mutate(nproteins_per_complex = rowSums(!is.na(across(starts_with("uniprot"))))) %>% 
  arrange(nproteins_per_complex) %>% 
  select(-nproteins_per_complex) %>% 
  knitr::kable()
```

```{r}
CCDB.complex2protein.uniq <- CCDB.complex2protein %>% 
  add_count(complex_key) %>% 
  filter(n == 1) %>% 
  select(-n)

CCDB.complex2protein.dup <- CCDB.complex2protein %>% 
  add_count(complex_key) %>% 
  filter(n > 1) %>% 
  select(-n) %>% 
  arrange(complex_key)
```

### Duplicate complex keys in CellChat

```{r}
CCDB.complex2protein.dup %>% 
  mutate(nproteins_per_complex = rowSums(!is.na(across(starts_with("uniprot"))))) %>% 
  arrange(nproteins_per_complex) %>% 
  select(-nproteins_per_complex) %>% 
  knitr::kable()
```

<br> Let's merge the unique records

```{r}
combined_unique <- full_join(CCDB.complex2protein.uniq, CPDB.complex2protein.uniq,
                             by = "complex_key", 
                             suffix = c(".CC", ".CP")) %>% 
                   relocate("complex_key")
```

```{r}
#| eval: false
combined_unique
```

```{r}
#| echo: false
datatable(combined_unique,
          options = list(
            scrollX = TRUE,
            scrollY = "50vh",
            paged = TRUE
          ))
```

<br> Save the output as excel file for manual mapping

```{r}
openxlsx::write.xlsx( 
  list( partial  = combined_unique,
        CCDB_dup = CCDB.complex2protein.dup,
        CPDB_dup = CPDB.complex2protein.dup), 
  file = "matched_partial_tmp.xlsx")
```

After manually mapping complexes to both databases and assigning them to a unique complex key, the mapped file contains six sheets listed as such:

```{r}
excel_sheets("matched_partial.xlsx")
```

### How duplicate keys were handled

#### CellPhoneDB

```{r}
CPDB.dup <- read_excel("matched_partial.xlsx", sheet = "CPDB_dup") 

CPDB.dup %>% 
  mutate(nproteins_per_complex = rowSums(!is.na(across(starts_with("uniprot"))))) %>% 
  arrange(nproteins_per_complex) %>% 
  select(-nproteins_per_complex) %>% 
  knitr::kable()
```

#### CellChat

```{r}
CCDB.dup <- read_excel("matched_partial.xlsx", sheet = "CCDB_dup")

CCDB.dup %>% 
  mutate(nproteins_per_complex = rowSums(!is.na(across(starts_with("uniprot"))))) %>% 
  arrange(nproteins_per_complex) %>% 
  select(-nproteins_per_complex) %>% 
  knitr::kable()
```

<br> We include a proposed complex key to differentiate complexes composed of the same subunits based on: <br> **(1)** functional context the complex operates (e.g. same complex producing different non-protein compounds) <br> **(2)** false annotation of uniprot ID to its corresponding gene (e.g. P30988 (CALCR) replaced to Q16602 (CALCRL) for CALCRL-containing complexes).

### Load the complete curated file

```{r}
complex <- read_excel("matched_partial.xlsx", sheet = "clean")

complex %>%  dim()
```

#### Mapped complexes file with the above `example` complexes for illustration

Each complex in CellChat and CellPhoneDB is now assigned a unique complex key

```{r}
complex %>% 
  filter(CellChat_name %in% example) %>% 
  mutate(CellChat_name = factor(CellChat_name, levels = example)) %>% 
  arrange(CellChat_name) %>% 
  knitr::kable()
```

#### Breakdown of complexes in the final list

```{r}
complex %>% 
  tabyl(match) %>% 
  arrange(desc(n))
```

<br> Following manual curation of the complexes and mapping based on uniprot IDs, the break down of the matching process is as shown above. We display the `manual`-mapped complexes, and `partial match` complexes which we define as sharing at least two subunits. <br>

```{r}
#| eval: false
complex %>% 
  filter(match %in% c("manual", "partial match")) %>% 
  mutate(nproteins_per_complex = rowSums(!is.na(across(starts_with("uniprot"))))) %>% 
  arrange(nproteins_per_complex) %>% 
  select(-nproteins_per_complex)
```

**Click** on the rows to view information in the **Note** column.

```{r}
#| echo: false
data <- complex %>% 
  filter(match %in% c("manual", "partial match")) %>% 
  mutate(nproteins_per_complex = rowSums(!is.na(across(starts_with("uniprot"))))) %>% 
  arrange(nproteins_per_complex) %>% 
  select(-nproteins_per_complex)

datatable(data,
          options = list(
            scrollX = TRUE, 
            scrollY = "50vh",
            paged = TRUE,
            columnDefs = list(
              list(targets = c(10), 
                   render = JS(
                     "function(data, type, row, meta) {",
                     "  return '<div style=\"white-space: nowrap; overflow: hidden; text-overflow: ellipsis;                         max-width: 180px;\">' + data + '</div>';",
                    "}"
                  ))
                ),
            rowCallback = JS("
              function(row, data) {
                $(row).on('click', function() {
                  var tr = $(this);
                  var table = $(tr).closest('table').DataTable();
                  var rowData = table.row(tr);
        
                  if (rowData.child.isShown()) {
                    rowData.child.hide();
                    tr.removeClass('shown');
                  } else {
                    var fullText = '<b>Note:</b> '  + data[10];
                    rowData.child(fullText).show();
                    tr.addClass('shown');
                  }
              });
            }
          ")
        ),
        class = 'stripe hover order-column compact'
)
```

#### Full complex mapping table

```{r}
#| eval: false
complex
```

```{r}
#| echo: false
datatable(complex,
          options = list(
            scrollX = TRUE,
            scrollY = "50vh",
            paged = TRUE
          ))
```

# 3. Gene Mapping

We map genes in both databases to their respective uniprot IDs for consistency.

## 3.1. Mapping CellPhoneDB genes to Uniprot IDs

### Preprocessing data

```{r}
rm(list = ls())
options(knitr.kable.NA = NA) # allow NA in kable from this section

CPDB.name2uniprot <- read_delim("data/uniprot_synonyms.tsv") %>% 
  clean_names() %>% 
  select(entry_name, entry)

CPDB.name2uniprot %>% dim()

CPDB.name2uniprot %>% 
  head()

CPDB.gene2name <- read_csv("data/gene_table.csv") %>% 
  arrange(desc(ensembl)) %>% 
  distinct(protein_id, .keep_all = T) 

CPDB.gene2name %>% dim()

CPDB.gene2name %>% 
  head() %>% 
  knitr::kable(align = rep("l", nrow(.)))
```

<br> We want to map **protein_name** in `CPDB.gene2name` to **entry** (uniprot ID) using `CPDB.name2uniprot`.

### Addressing invalid data points (i.e. non-uniprot protein name, missing entries)

Some proteins did not have a valid uniprot name (no "\_HUMAN" in the protein name). Therefore, we manually added the uniprot name with reference from <https://www.uniprot.org/>.

```{r}
CPDB.gene2name$protein_name[!grepl("HUMAN$", CPDB.gene2name$protein_name)]

# fill in missing entry names
CPDB.gene2name <- CPDB.gene2name %>% 
  mutate(protein_name = case_when(
    protein_name %in% c("HLAA", "HLAB", "HLAC") ~ paste0(protein_name, "_HUMAN"),
    protein_name == "CCL3L1" ~ "CL3L1_HUMAN",
    protein_name == "IFNA1" ~ "L0N195_HUMAN",
    .default = protein_name
  )) %>% 

# mapping from uniprot protein name to the corresponding uniprot IDs
  left_join(CPDB.name2uniprot %>% 
    select(entry, entry_name), by = c("protein_name" = "entry_name"))

CPDB.gene2name %>% dim()

CPDB.gene2name %>% 
  head() %>% 
  knitr::kable(align = rep("l", nrow(.)))

rm(CPDB.name2uniprot)
```

### Using biomaRt database to map from Ensembl ID to uniprot ID

For genes without a successful map, we used the biomaRt database to map the genes to their corresponding uniprot IDs via an Ensembl-to-Uniprot mapping.

```{r}
na.genes <- CPDB.gene2name$ensembl[is.na(CPDB.gene2name$entry)]
na.genes

# Load biomaRt database
mart <- useMart('ENSEMBL_MART_ENSEMBL')
mart <- useDataset('hsapiens_gene_ensembl', mart)

# listAttributes(mart) %>% view()

annotLookup <- getBM(
  mart = mart,
  attributes = c(
  'hgnc_symbol',
  'ensembl_gene_id',
  'uniprotswissprot'),
  uniqueRows = TRUE) %>% 
  arrange(desc(uniprotswissprot)) %>% 
  distinct(ensembl_gene_id, .keep_all = T) %>% 
  filter(uniprotswissprot != "")

annotLookup %>% dim()

annotLookup %>% head()

CPDB.gene2name <- CPDB.gene2name %>% 
  left_join(annotLookup %>% 
    select(-hgnc_symbol), by = c("ensembl" = "ensembl_gene_id")) %>% 
  mutate(entry = ifelse(ensembl %in% na.genes, uniprotswissprot, entry),
         agree = ifelse(entry == uniprotswissprot, T, F))

CPDB.gene2name %>% dim()

CPDB.gene2name %>% 
  head() %>% 
  knitr::kable(align = rep("l", nrow(.)))

rm(na.genes, mart, annotLookup)
```

### Manual check for genes that do not match

```{r}
CPDB.gene2name %>% 
  tabyl(agree) %>% 
  knitr::kable()

false.genes <- na.omit(CPDB.gene2name$ensembl[CPDB.gene2name$agree == F])

CPDB.gene2name %>% 
  filter(ensembl %in% false.genes) %>% 
  knitr::kable(align = rep("l", nrow(.)))

# Manual check
# ENSG00000197919 use uniprotswissprot
# ENSG00000179915, ENSG00000171867, ENSG00000110680, ENSG00000110076, ENSG00000101307, ENSG00000021645 unchanged

CPDB.gene2uniprot <- CPDB.gene2name %>% 
  mutate(entry = ifelse(ensembl == "ENSG00000197919", uniprotswissprot, entry)) %>% 
  rename(uniprot_id = entry) %>% 
  select(-uniprotswissprot, - agree)

write_csv(CPDB.gene2uniprot, file = "results/gene_cellphonedb.csv")

CPDB.gene2uniprot %>% dim()
```

### Full CellPhoneDB gene mapping table {#full-cellphonedb-gene-mapping-table}

```{r}
#| eval: false
CPDB.gene2uniprot
```

```{r}
#| echo: false
datatable(CPDB.gene2uniprot, 
          options = list(
            scrollX = TRUE,
            scrollY = "50vh",
            paged = TRUE
          ))
```

```{r}
rm(false.genes, CPDB.gene2name, CPDB.gene2uniprot)
```

## 3.2. Mapping CellChat genes to Uniprot IDs

```{r}
CCDB.gene2uniprot <- CellChatDB.human$geneInfo %>% 
  clean_names()

na.genes <- CCDB.gene2uniprot$symbol[(is.na(CCDB.gene2uniprot$entry_id_uniprot))]

na.genes

CCDB.gene2uniprot <- CCDB.gene2uniprot %>% 
  mutate(entry_id_uniprot = case_when(
    symbol %in% c("CCL3L1", "CCL3L3") ~ "P16619",
    symbol == "GPR1" ~ "P46091",
    .default = entry_id_uniprot
))

CCDB.gene2uniprot %>% dim()
```

### Full CellChat gene mapping table {#full-cellchat-gene-mapping-table}

```{r}
#| eval: false
CCDB.gene2uniprot
```

**Click** on the rows if you wish to extract full information on **protein_name**, **keywords** and **location**.

```{r}
#| echo: false
datatable(CCDB.gene2uniprot,
          options = list(
            scrollX = TRUE,
            scrollY = "40vh",
            paged = TRUE,
            columnDefs = list(
              list(targets = c(6, 7, 8), 
                   render = JS(
                     "function(data, type, row, meta) {",
                     "  return '<div style=\"white-space: nowrap; overflow: hidden; text-overflow: ellipsis;                         max-width: 180px;\">' + data + '</div>';",
                    "}"
                  ))
                ),
            rowCallback = JS("
              function(row, data) {
                $(row).on('click', function() {
                  var tr = $(this);
                  var table = $(tr).closest('table').DataTable();
                  var rowData = table.row(tr);
        
                  if (rowData.child.isShown()) {
                    rowData.child.hide();
                    tr.removeClass('shown');
                  } else {
                    var fullText = '<b>protein_name:</b> '  + data[6] + 
                                   '<br/><b>keywords:</b> ' + data[7] + 
                                   '<br/><b>location:</b> ' + data[8];
                    rowData.child(fullText).show();
                    tr.addClass('shown');
                  }
              });
          }
      ")
   ),
  class = 'stripe hover order-column compact'
)
```

```{r}
write_csv(CCDB.gene2uniprot, file = "results/gene_cellchat.csv")

rm(na.genes, CCDB.gene2uniprot)
```

# 4. Interaction Database Mapping

## 4.1. Mapping CellPhoneDB interactions

CellPhoneDB interaction database is set up such that the interacting partners (**multidata_1_id** and **multidata_2_id**) are in the form of its database-specific IDs. Here, we trace them back to the uniprot form we assigned.

```{r}
CPDB <- read_csv("data/interaction_table.csv")

CPDB %>% dim()

CPDB %>% 
  head() %>% 
  knitr::kable(align = rep("l", nrow(.))) %>% 
  column_spec(c(3, 4), color = "red")
```

### Mapping CellPhoneDB's interaction database (gene)

```{r}
CPDB.gene <- read_csv("results/gene_cellphonedb.csv")
```

Recall CellPhoneDB gene mapping table [here](#full-cellphonedb-gene-mapping-table)

```{r}
CPDB <- CPDB %>% 
  # adding uniprot and gene names to interaction database
  left_join(CPDB.gene %>% 
    select(protein_id, uniprot_id, gene_name), by = c("multidata_1_id" = "protein_id")) %>% 
  mutate(multidata_1_id = ifelse(!is.na(uniprot_id), uniprot_id, multidata_1_id),
         partner_1 = ifelse(!is.na(gene_name), gene_name, NA)) %>% 
  select(-uniprot_id, -gene_name) %>% 
  
  left_join(CPDB.gene %>% 
    select(protein_id, uniprot_id, gene_name), by = c("multidata_2_id" = "protein_id")) %>% 
  mutate(multidata_2_id = ifelse(!is.na(uniprot_id), uniprot_id, multidata_2_id),
         partner_2 = ifelse(!is.na(gene_name), gene_name, NA)) %>% 
  select(-uniprot_id, -gene_name)

CPDB %>% dim()

CPDB %>% 
  head() %>% 
  knitr::kable(align = rep("l", nrow(.))) %>% 
  column_spec(3, color = "green") %>% 
  column_spec(4, color = "red")
```

### Mapping CellPhoneDB's interaction database (complex)

Load necessary data

```{r}
multidata <- read_csv("data/multidata_table.csv") %>% 
  select(id_multidata, name)

multidata %>% dim()

multidata %>% tail()

complex.map <- read_excel("matched_partial.xlsx", sheet = "clean") %>% 
  select(complex_key, CellChat_name, CellPhoneDB_name) %>% 
  left_join(multidata, by = c("CellPhoneDB_name" = "name")) %>% 
  mutate(id_multidata = as.character(id_multidata))

complex.map %>% dim()

complex.map %>% 
  head() %>% 
  knitr::kable()

rm(multidata)
```

```{r}
CPDB <- CPDB %>% 
  # adding complex uniprot id and name of complexes
  left_join(complex.map %>% 
    select(complex_key, id_multidata, CellPhoneDB_name), by = c("multidata_1_id" = "id_multidata")) %>% 
  mutate(multidata_1_id = ifelse(!is.na(complex_key), complex_key, multidata_1_id),
         partner_1 = ifelse(!is.na(CellPhoneDB_name), CellPhoneDB_name, partner_1)) %>% 
  select(-complex_key, -CellPhoneDB_name) %>% 
  
  left_join(complex.map %>% 
    select(complex_key, id_multidata, CellPhoneDB_name), by = c("multidata_2_id" = "id_multidata")) %>% 
  mutate(multidata_2_id = ifelse(!is.na(complex_key), complex_key, multidata_2_id),
         partner_2 = ifelse(!is.na(CellPhoneDB_name), CellPhoneDB_name, partner_2)) %>% 
  select(-complex_key, -CellPhoneDB_name) %>% 
  distinct()

CPDB <- CPDB %>% 
  mutate(unique_int = paste(multidata_1_id, multidata_2_id, sep = "_"))

CPDB %>% dim()
```

Now, all interacting partners in CellPhoneDB are in the form of uniprot IDs/complex keys:

```{r}
CPDB %>% 
  head() %>% 
  knitr::kable(align = rep("l", nrow(.))) %>% 
  column_spec(c(3, 4), color = "green")
```

## 4.2. Mapping CellChatDB interactions

We now do the same mapping in CellChat's interaction database to convert the interacting partners to uniprot ID format.

### Mapping CellChat's interaction database (gene)

```{r}
CCDB.gene <- read_csv("results/gene_cellchat.csv")
```

Recall CellChat gene mapping table [here](#full-cellchat-gene-mapping-table)

```{r}
# Name to Uniprot (Gene) ----
CCDB <- CellChatDB.human$interaction %>% 
  left_join(CCDB.gene %>% 
    select(entry_id_uniprot, symbol), by = c("ligand" = "symbol")) %>% 
  mutate(ligand = ifelse(!is.na(entry_id_uniprot), entry_id_uniprot, ligand)) %>% 
  select(-entry_id_uniprot) %>% 

  left_join(CCDB.gene %>% 
    select(entry_id_uniprot, symbol), by = c("receptor" = "symbol")) %>% 
  mutate(receptor = ifelse(!is.na(entry_id_uniprot), entry_id_uniprot, receptor)) %>% 
  select(-entry_id_uniprot)
```

### Mapping CellChat's interaction database (complex)

```{r}
# Name to Uniprot (Complex) ----
CCDB <- CCDB %>% 
  left_join(complex.map %>% 
    select(complex_key, CellChat_name), by = c("ligand" = "CellChat_name")) %>% 
  mutate(ligand = ifelse(!is.na(complex_key),complex_key, ligand)) %>% 
  select(-complex_key) %>% 

  left_join(complex.map %>% 
    select(complex_key, CellChat_name), by = c("receptor" = "CellChat_name")) %>% 
  mutate(receptor = ifelse(!is.na(complex_key), complex_key, receptor)) %>% 
  select(-complex_key)

rm(CCDB.gene)

CCDB <- CCDB %>% 
  mutate(unique_int = paste(ligand, receptor, sep = "_")) %>% 
  rename(uniprot_ligand = ligand, uniprot_receptor = receptor)

CCDB %>% dim()
```

### View full CellChat interaction mapping table {#view-full-cellchat-interaction-mapping-table}

```{r}
#| eval: false
CCDB
```

You may **click** on the rows if you wish to view information of the L-R location and keywords.

```{r}
#| echo: false

datatable(CCDB,
          options = list(
            scrollX = TRUE,
            scrollY = "60vh",
            paging = TRUE,
            columnDefs = list(
              list(targets = c(15, 16, 21, 22), 
                   render = JS(
                     "function(data, type, row, meta) {",
                     "  return '<div style=\"white-space: nowrap; overflow: hidden; text-overflow: ellipsis;                         max-width: 180px;\">' + data + '</div>';",
                    "}"
                  ))
                ),
            rowCallback = JS("
              function(row, data) {
                $(row).on('click', function() {
                  var tr = $(this);
                  var table = $(tr).closest('table').DataTable();
                  var rowData = table.row(tr);
        
                  if (rowData.child.isShown()) {
                    rowData.child.hide();
                    tr.removeClass('shown');
                  } else {
                    var fullText = '<b>ligand.location:</b> '        + data[15] + 
                                   '<br/><b>ligand.keyword:</b> '    + data[16] + 
                                   '<br/><b>receptor.location:</b> ' + data[21] + 
                                   '<br/><b>receptor.keyword:</b> '  + data[22];
                    rowData.child(fullText).show();
                    tr.addClass('shown');
                  }
              });
          }
        ")
    ),
  class = 'stripe hover order-column compact'
)
```

## 4.3. Overlap analysis of databases

We found that some interactions across the CellChat and CellPhoneDB's interaction databases were the same, but their interacting partner were simply flipped.

e.g. Partner A was denoted the "ligand" in CellChat, but "receptor" in CellPhoneDB, with the corresponding flipped order for its partner B ("receptor" in CellChat and "ligand" in CellPhoneDB).

This is common for interactions that fall in the **"Cell-Cell Contact"** category. To identify these interactions, we extracted the L-R interactions that were found only in CellChat and kept interactions where both ligand and receptor are found in CellPhoneDB as well. This is because when at least one interacting partner is not found in CellPhoneDB, that interaction will not map to CellPhoneDB's interaction database - flipped or not.

We looked at which interactions were mapped to CellPhoneDB after we perform a flip of CellChat's interaction data, and assigned the ligand-receptor pair directionality in CellPhoneDB with respect to CellChat.

```{r}
diff.int <- setdiff(CCDB$unique_int, CPDB$unique_int) # 1039 NOT in CellPhoneDBv5
cpdb.lr <- c(CPDB$multidata_1_id, CPDB$multidata_2_id) %>% 
  unique()

diff.df <- CCDB %>% 
  filter(unique_int %in% diff.int,
         uniprot_ligand %in% cpdb.lr, # keep only relevant to CellPhoneDB
         uniprot_receptor %in% cpdb.lr) 

diff.df %>% dim() # 410
```

There are 410 **unmapped** interactions in CellChat's interaction database, where **both** ligand and receptor can be found in CellPhoneDB.

What happens to the number of unmapped interactions when we perform flip?

```{r}
diff.df <- diff.df %>% 
  mutate(flipped = paste(uniprot_receptor, uniprot_ligand, sep = "_"))

new.diff <- setdiff(diff.df$flipped, CPDB$unique_int)
length(new.diff) # 362
```

After performing a flip of the interacting partners, we observe that the number of unmapped interaction now becomes `r length(new.diff)`. This indicates that after flip, 48 interactions mapped to CellPhoneDB's interaction. Therefore, we say that these 48 interactions in CellPhoneDB have their partners reversed with respect to CellChat.

```{r}
flip.df <- diff.df %>% 
  filter(!(flipped %in% new.diff)) %>% 
  select(-agonist, -antagonist, -starts_with("co_")) # remove cols with NA

flip.df %>% dim()
```

```{r}
#| eval: false
flip.df
```

You may **click** on the rows if you wish to view information of the L-R location and keywords.

```{r}
#| echo: false

datatable(flip.df,
          options = list(
            scrollX = TRUE,
            scrollY = "60vh",
            paging = TRUE,
            columnDefs = list(
              list(targets = c(11, 12, 17, 18), render = JS(
                "function(data, type, row, meta) {",
                "  return '<div style=\"white-space: nowrap; overflow: hidden; text-overflow: ellipsis;                         max-width: 180px;\">' + data + '</div>';",
                "}"
              ))
            ),
            rowCallback = JS("
              function(row, data) {
                $(row).on('click', function() {
                  var tr = $(this);
                  var table = $(tr).closest('table').DataTable();
                  var rowData = table.row(tr);
        
                  if (rowData.child.isShown()) {
                    rowData.child.hide();
                    tr.removeClass('shown');
                  } else {
                    var fullText = '<b>ligand.location:</b> '        + data[11] + 
                                   '<br/><b>ligand.keyword:</b> '    + data[12] + 
                                   '<br/><b>receptor.location:</b> ' + data[17] + 
                                   '<br/><b>receptor.keyword:</b> '  + data[18];
                    rowData.child(fullText).show();
                    tr.addClass('shown');
                  }
              });
          }
      ")
    ),
  class = 'stripe hover order-column compact'
)
```

### Interactions to flip were under "Cell-Cell Contact" category

```{r}
flip.df %>% 
  tabyl(annotation) %>% 
  knitr::kable(align = rep("l", nrow(.)))
```

### Visualising overlap between CellPhoneDB and CellChat's interaction database

```{r}
to.flip <- flip.df$flipped

rm(diff.df, flip.df, cpdb.lr, diff.int, new.diff)

CPDB <- CPDB %>% 
  mutate(ligand     = ifelse(unique_int %in% to.flip, multidata_2_id, multidata_1_id),
         from       = ifelse(unique_int %in% to.flip, partner_2, partner_1), # gene / complex name
         receptor   = ifelse(unique_int %in% to.flip, multidata_1_id, multidata_2_id),
         to         = ifelse(unique_int %in% to.flip, partner_1, partner_2), # gene / complex name
         unique_int = paste(ligand, receptor, sep = "_")) %>% 
  select(-starts_with("partner"), - starts_with("multi"))

rm(to.flip)

ggvenn(list(CellPhoneDBv5 = CPDB$unique_int, CellChatDBv2 = CCDB$unique_int))

write_csv(CPDB, file = "results/mapped_cellphonedb.csv")
write_csv(CCDB, file = "results/mapped_cellchatdb.csv")
```

### View full CellPhoneDB interaction mapping table

```{r}
#| eval: false
CPDB
```

```{r}
#| echo: false
datatable(CPDB,
          options = list(
            scrollX = TRUE,
            scrollY = "60vh",
            paged = TRUE
          ))
```

<br> View the full CellChat interaction mapping table back [here](#view-full-cellchat-interaction-mapping-table)!

```{r}
#| echo: false
knitr::knit_exit()
```
